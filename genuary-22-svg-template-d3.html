<!doctype html><html><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>SVG template</title>
<style>
  *{border:none;margin:0;padding:0;box-sizing:border-box}
  body{background:#345}
  img{width:100vw;height:100vh;object-fit:contain;position:absolute}
</style>
</head><body><script>

// *** PITER'S TOTALLY SIMPLE PLOTTER READY SVG DRAWING TEMPLATE ***

// URL options, defaults
OPTS={
  // define physical paper size. note, a common max size for plotters is A3 paper size or 420x297mm.
  mmh: 140,     // page height in mm (equals inches * 25.4) 
  aspect: 4/5,  // aspect ratio (width divided by height)
  lw: .9,       // pen line width in mm. many fine liners are about 0.3mm wide. if you have a pen, and a plotter, and
                // want to experimentally find out its exact line width, see https://piterpasma.nl/articles/line-test 
  res: .01,
  bgrect: 1,    // whether we want a background rectangle. SVGs are transparent by default unless you put a big rect
                // behind everything. This is useful for copying/sharing the img to social media, but when plotting 
                // the SVG you don't want to plot this rect, so you can use this option to turn it off.

  // seed:'falurpaa', // not so random seed
  seed:'flurp'+Date.now(), // random seed
};

// here comes the code
(code=_=>{
  // update the default opts from the URL search params and output as a nice table to the console
  console.table(OPTS={...OPTS,...Object.fromEntries(new URL(location).searchParams)});

  // random number generator
  console.log(`Random seed = ${OPTS.seed}`);
  PRNGG=(s,a=9,b,c,d,R=(x=1)=>x*(x=d^d<<11,d=c,c=b,b=a,((a^=x^x>>>8^(b>>>19))>>>0)/2**32))=>([...s+'ThxPiter'].map(e=>R(d^=e.charCodeAt()*a)),R); // pseudo random number generator generator
  R=PRNGG(OPTS.seed); // your PRNG
  // random functions
  RS=(a=1)=>R()<.5?a:-a; // random sign 1 / -1
  RR=(a=1,b=-a)=>a+R(b-a); // uniform random range [a..b]
  RA=a=>a[R(a.length)|0]; // random element from Array
  T=a=>R(a)-R(a); // triangular distribution

  // get some math definitions and useful functions
  ({abs,sin,cos,PI,max,min,floor}=Math); TAU=PI*2;
  A3=([x,y,z=0],[a,b,c=0],t=1)=>[x+a*t,y+b*t,z+c*t]; // vec3 add
  A=([x=0,y=0],[a,b],t=1)=>[x+a*t,y+b*t]; // vec2 add/mul
  CM=([x,y],[a,b])=>[a*x-b*y, b*x+a*y];
// V cmul(V a, V b) {
//   return V();
// }

  L=(x,y,z=0)=>(x*x+y*y+z*z)**.5;
  Lv2=([x,y])=>(x*x+y*y)**.5;
  H=([x,y,z=0],[a,b,c=0])=>L(x-a,y-b,z-c);

  mag=0;N=([x,y,z])=>[x/(mag=1e-99+(x*x+y*y+z*z)**.5),y/mag,z/mag]; // vec3 normalize + save length in mag
  X=([x,y,z],[a,b,c])=>[y*c-z*b,z*a-x*c,x*b-y*a]; // vec3 cross product
  D=([x,y,z=0],[a,b,c=0])=>x*a+y*b+z*c; // vec2/vec3 dot product

  F=(N,f)=>[...Array(N)].map((_,i)=>f(i)); // loop function
  SM=(a,b,x)=>(x-=a,x/=b-a)<0?0:x>1?1:x*x*(3-2*x); // smoothstep 48
  cl=(x,a,b)=>x<a?a:x>b?b:x; // clamp

  let B=abs,U=min,G=max,k=(a,b)=>a>0&&b>0?(a*a+b*b)**.5:a>b?a:b;
  let mx2=([a,b],[c,d],t=.5,s=1-t)=>[s*a+t*c,s*b+t*d];

  // define coordinates
  aspect = OPTS.aspect;
  // While the page size is in physical units, the coordinates for drawing into the SVG are based on its "viewbox",
  // which we can set to any size we like (very nice). We'll set it to a height of 1000 units.
  VH = 1000; // viewbox height
  VW = VH * aspect; // viewbox width
  LW = OPTS.lw/OPTS.mmh*VH; // line width in viewbox units (like a pixel it's the smallest size you can draw)
  VH2=VH/2;VW2=VW/2;

  drawing = _=> {
    // A plotter only draws lines. 
    // A drawing is an Array (list) of lines (paths),
    // A path (line) is an Array of points. 
    // A point is a 2-element Array [x,y].
    // so we return an Array of Arrays of points.
    let result = [];

    // let's define some shapes
    // a shape is a closed path and we close a path by going back to the first point
    close=a=>[...a,a[0]];
    rrot=(a,i=R(a.length|0))=>[...a.slice(i),...a.slice(0,i)];

    circle=(x,y,r,N=.5*TAU*r/LW|0,a0=0)=>F(N,i=>[cos(i=i*TAU/N+a0)*r+x,sin(i)*r+y]); // a circle


    wob=([p0,p1,p2,p3]=F(4,_=>R(TAU)),[f0,f1,f2,f3]=F(4,_=>.012*3**T()))=>([x,y])=>sin(x*f0+p0+a0+3*sin(y*f1+p1+a1)**3)*sin(y*f2+p2+a2+3*sin(x*f3+p3+a3)**3);

    fp = (pp,i,N=pp.length,f=i-(i=floor(i)))=>mx2(pp[i++],pp[i>=N?i-N:i],f);
    pdiz = (pp,d0=LW*.75)=>{
      let i = 0, p = pp[i], res = [p], q = pp[++i];
      let dp =A(q, p, -1), d = Lv2(dp);
      dp = A([],dp,d0/d);    
      for(;q;){
        if (d > d0) {
          p = A(p, dp);
          d -= d0;
          res.push(p);
        } else {
          q = pp[++i];
          if(!q)break;
          dp = A(q,p,-1); d = Lv2(dp);
          dp = A([],dp,d0/d);
        }
      }
      return res;
    }

    makshap = (wx,wy)=>{
      let kip = close(rrot(circle(VW2,VH2,VW2*.5)));
      for(let i=0;i<300; i++){
        console.log(i);
        let N = kip.length, q;
        let cp = A([-VW2,-VH2],kip.reduce((a,c)=>A(a,c)),1/N)
        kip = kip.map((p,i)=>A(p,A([wx(p),wy(p)],cp,-1),1));
        kip=pdiz(close(rrot(kip)));
      }
      return kip;
    }

    ([a0,a1,a2,a3]=F(4,_=>R(TAU)));
    let w0 = wob(), w1 = wob();
    result.push(makshap(w0,w1));

    // let difc = .01;
    // let fdc = d=>-difc * (SM(LW*9,LW*6,d)-4*SM(LW*3,0,d));
    // let wx = wob(), wy = wob();
    return result;
  }

  make_svg = lines => {
    // OK let's build an SVG

    // By default JS prints about 17 decimals after the point, and we really don't need that many, it just 
    // bloats the SVG. So we round all our numbers to 2 decimals.
    let fix = x => (x*1).toFixed(2); // Multiply by 1 to force cast to a Number, and round to two decimals.
    let fix2 = ([x, y]) => [fix(x), fix(y)]; // Coordinates are Arrays and it's useful to round those too.

    // SVG comment helper function (avoid writing "minus minus" in the SVG, for reasons)
    let cmt = (str, d='-' + '-') => `<!${d} ${str.replaceAll(d, '_-_-_')} ${d}>`;

    // SVG path definition.
    let path=([q, ...pp]) => `M ${fix2(q)} L ` + pp.map(fix2).join(` `); // (M)ove to first coord, then (L)ine to rest

    // Reumann-Witkam line simplification function
    let LD=([a,b],[c,d],e=c-a,f=d-b,l=L(e,f),z=c*b-d*a)=>([x,y])=>l>0?B(f*x-e*y+z)/l:L(a-x,b-y); // perpendicular distance between point [x,y] and ray [a,b]->[c,d]
    let simplify=([o,p,...s],t,r=[o],q=p,ra=LD(o,p))=>(s.map(p=>{if(ra(p)>t){r.push(q);ra=LD(q,p)}q=p}),[...r,q]); // use flatMap?
    console.log(`N pts = ${lines.flat().length}`);
    lines = lines.map(line=>simplify(line,LW*OPTS.res));
    console.log(`N pts simplified = ${lines.flat().length}`);

    let svg=[
      // starting with the main svg tag, don't forget to close it later
      `<svg xmlns="http://www.w3.org/2000/svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" viewBox="0 0 ${fix(VW)} ${fix(VH)}" width="${fix(OPTS.mmh * aspect)}mm" height="${fix(OPTS.mmh)}mm">`,

      // let's comment the date!
      cmt(Date()), 

      // in fact, let's comment the OPTS options and the entire code of this very program, 
      // because we can (hah, and you thought Genuary day 11 "Quine" was a useless exercise!)
      cmt(`\n\nOPTS=${JSON.stringify(OPTS,null,2)};\n(code=${code})();\n\n`)
    ];

    // now we append a background rectangle maybe
    if(OPTS.bgrect>0) {
      svg.push(
        // this <g> group tag makes Axidraw plotters ignore the bg rect
        `<g inkscape:groupmode="layer" inkscape:label="%">`,
        // but not all plotters support that, so we also make the bg rect way larger than the page, which should 
        // give an error when trying to plot, if you forgot to remove it (because you really don't want the plotter 
        // to draw exactly at the edges of a paper)
        `<rect x="${fix(-VW)}" y="${fix(-VH)}" width="${fix(VW*3)}" height="${fix(VH*3)}" fill="#dddddd" />`,
        `</g>`
      );
    }

    svg.push(
      // now we make a group element <g>, to define a lot of properties for the lines inside it at once
      `<g fill="#009" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="${fix(LW)}">`,
      // we can put all the paths of the drawing in one big path definition, it's fine
      `<path d="${lines.map(pp=>path(pp)).join(' ')} Z" />`,
      // close the group
      `</g>`,
      // close the svg
      `</svg>`
    );

    return svg;
  }

  // put the SVG into the image
  let start_time = Date.now();
  let im = new Image();
  let blob = new Blob(make_svg(drawing()),{type:'image/svg+xml'});
  im.src=URL.createObjectURL(blob);
  // put the image into the webpage
  document.body.append(im);

  console.log(`Done in ${(Date.now()-start_time)|0}ms. SVG size = ${(blob.size/1000|0).toFixed(1)}KB`);
})();

onkeyup=e=>{
  // Keyboard shortcuts:
  //
  // L - lock seed
  // U - unlock seed
  // S - save SVG

  if(e.key=='l'){
    // press L to lock seed
    location.search=`seed=${OPTS.seed}`;
  }
  if(e.key=='u'){
    // press U to unlock seed
    location.search=``;
  }
  if(e.key=='s'){
    // press S to save
    a=document.createElement('a');
    d=new Date();
    let filename=['FullYear','Month','Date','Hours','Minutes'].map((v,i)=>(d['get'+v]()+(i==1)+'').padStart(2,0)).join('-')+`-output-${1000+R(8999)|0}.svg`;
    a.download=filename;
    console.log(`SAVING ${filename}`);
    a.href=document.querySelector('img').src;
    a.click();
  }
}
</script>
<script id=livereload></script>
<script>
  if(location.hostname==='localhost') {
    livereload.src = `http://localhost:35729/livereload.js`;
  }
</script>

</body></html>